options {
  STATIC = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(GroupPromQLParser)
import java.io.*;
import java.util.*;
import ast.*;

public class GroupPromQLParser {
    public static GroupInstantVector parseGroupInstant(String query) throws ParseException {
        if (query == null || query.trim().isEmpty()) return null;
        GroupPromQLParser parser = new GroupPromQLParser(new StringReader(query));
        return parser.Start();
    }

    private boolean isAggOverTime(String s) {
        return s.equalsIgnoreCase("sum_over_time") || 
               s.equalsIgnoreCase("count_over_time") || 
               s.equalsIgnoreCase("min_over_time") || 
               s.equalsIgnoreCase("max_over_time") || 
               s.equalsIgnoreCase("avg_over_time") || 
               s.equalsIgnoreCase("stddev_over_time") ||
               s.equalsIgnoreCase("stddev_samp_over_time");
    }

    private boolean isGroupBy(String s) {
        return s.equalsIgnoreCase("group_by");
    }

    private boolean isAggBy(String s) {
        return s.equalsIgnoreCase("sum_by") || 
               s.equalsIgnoreCase("count_by") || 
               s.equalsIgnoreCase("min_by") || 
               s.equalsIgnoreCase("max_by") || 
               s.equalsIgnoreCase("avg_by") || 
               s.equalsIgnoreCase("stddev_samp_by");
    }

    private String getAggName(String s) {
        if (s.toLowerCase().endsWith("_by")) {
            return s.substring(0, s.length() - 3);
        }
        return s;
    }
}
PARSER_END(GroupPromQLParser)

SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN : {
    < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < COMMA: "," >
  | < NEQ: "!=" >
  | < EQUALS: "=" >
  | < GROUP_BY: "group_by" >
  | < NUMBER: (["0"-"9"])+ ("." (["0"-"9"])+)? >
  | < STRING: "\"" (~["\"","\\"] | "\\" ~[])* "\"" | "'" (~["'","\\"] | "\\" ~[])* "'" >
  | < DURATION: (["0"-"9"])+ ["s","m","h","d","w","y"] >
  | < IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
}

GroupInstantVector Start() :
{ GroupInstantVector node; }
{
  node = GroupInstant() <EOF>
  { return node; }
}

GroupInstantVector GroupInstant() :
{ GroupInstantVector node; Token t; }
{
  (
    LOOKAHEAD(<GROUP_BY>) node = GroupByClause()
    | LOOKAHEAD(<IDENTIFIER> <LBRACKET>, { isAggBy(getToken(1).image) }) node = AggByClause()
    | LOOKAHEAD(<IDENTIFIER> <LPAREN>, { isAggOverTime(getToken(1).image) }) node = AggOverTime()
    | node = MetricSelector()
  )
  { return node; }
}

GroupInstantVector MetricSelector() :
{ Token name; List<LabelFilter> filters = new ArrayList<LabelFilter>(); }
{
  name = <IDENTIFIER>
  ( <LBRACE> FilterList(filters) <RBRACE> )?
  { return new GroupBy(new ArrayList<String>(), name.image, filters); }
}

ast.MetricSelector ParseMetricSelector() :
{ Token name; List<LabelFilter> filters = new ArrayList<LabelFilter>(); }
{
  name = <IDENTIFIER>
  ( <LBRACE> FilterList(filters) <RBRACE> )?
  { return new ast.MetricSelector(name.image, filters); }
}

void FilterList(List<LabelFilter> filters) :
{ Token k, v, op; }
{
  k = <IDENTIFIER> ( op=<EQUALS> | op=<NEQ> ) v = <STRING>
  { filters.add(new LabelFilter(k.image, op.image, v.image.substring(1, v.image.length()-1))); }
  ( <COMMA> k = <IDENTIFIER> ( op=<EQUALS> | op=<NEQ> ) v = <STRING>
    { filters.add(new LabelFilter(k.image, op.image, v.image.substring(1, v.image.length()-1))); }
  )*
}

GroupInstantVector GroupByClause() :
{ List<String> cols = new ArrayList<String>(); ast.MetricSelector metric; }
{
    <GROUP_BY> <LBRACKET> ColumnList(cols) <RBRACKET> <LPAREN> metric = ParseMetricSelector() <RPAREN>
    { return new GroupBy(cols, metric.getMetricName(), metric.getLabelFilters()); }
}

GroupInstantVector AggByClause() :
{ List<String> cols = new ArrayList<String>(); ast.MetricSelector metric; Token t; String aggName; Token duration; }
{
    t = <IDENTIFIER>
    {
        if (!isAggBy(t.image)) {
             throw new ParseException("Expected agg_by function (sum_by, etc.), found: " + t.image);
        }
        aggName = getAggName(t.image);
    }
    <LBRACKET> ColumnList(cols) <RBRACKET> <LPAREN> metric = ParseMetricSelector() <LBRACKET> duration = <DURATION> <RBRACKET> <RPAREN>
    { 
       return new AggBy(aggName, cols, metric.getMetricName(), metric.getLabelFilters(), duration.image);
    }
}

void ColumnList(List<String> cols) :
{ Token t; }
{
    t = <IDENTIFIER> { cols.add(t.image); }
    ( <COMMA> t = <IDENTIFIER> { cols.add(t.image); } )*
}

GroupInstantVector AggOverTime() :
{ Token funcName; GroupRangeVector range; }
{
    funcName=<IDENTIFIER>
    {
       if (!isAggOverTime(funcName.image)) {
           throw new ParseException("Expected agg_over_time function, found: " + funcName.image);
       }
    }
    <LPAREN> range = GroupRange() <RPAREN>
    { return new GroupAggOverTime(funcName.image, range); }
}

GroupRangeVector GroupRange() :
{ GroupInstantVector vec; Token dur; }
{
    vec = GroupInstant() <LBRACKET> dur = <DURATION> <RBRACKET>
    { return new GroupRangeVector(vec, dur.image); }
}

